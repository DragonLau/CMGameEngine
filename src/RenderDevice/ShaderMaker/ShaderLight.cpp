namespace hgl
{
	namespace graph
	{
		namespace shadergen
		{
			const char glsl_light_directional[]=
					"struct DirectionLight\n"
					"{\n"
					"\tvec3 direction;\n"
					"\tvec4 halfVector;\n"
					"\n"
					"\tvec4 ambient;\n"
					"\tvec4 specular;\n"
					"\tvec4 diffuse;\n"
					"};\n"
					"\n"
					"void directionalLight(in int i, in vec3 normal)\n"
					"{\n"
					"   float nDotVP;         // normal . light direction\n"
					"   float nDotHV;         // normal . light half vector\n"
					"   float pf;             // power factor\n\n"
					"   nDotVP = max(0.0, dot(normal, normalize(vec3 (DirectionLightSource[i].direction))));\n"
					"   nDotHV = max(0.0, dot(normal, vec3 (DirectionLightSource[i].halfVector)));\n\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += DirectionLightSource[i].ambient;\n"
					"   Diffuse  += DirectionLightSource[i].diffuse * nDotVP;\n"
					"   Specular += DirectionLightSource[i].specular * pf;\n"
					"}\n";

			const char glsl_light_point[]=
					"struct PointLight\n"
					"{\n"
					"\tvec3 position;\n"
					"\tvec4 halfVector;\n"
					"\tvec3 attenuation'\n"
					"\n"
					"\tvec4 ambient;\n"
					"\tvec4 specular;\n"
					"\tvec4 diffuse;\n"
					"};\n"
					"\n"
					"void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)\n"
					"{\n"
					"   float nDotVP;       // normal . light direction\n"
					"   float nDotHV;       // normal . light half vector\n"
					"   float pf;           // power factor\n"
					"   float attenuation;  // computed attenuation factor\n"
					"   float d;            // distance from surface to light source\n"
					"   vec3  VP;           // direction from surface to light position\n"
					"   vec3  halfVector;   // direction of maximum highlights\n\n"
					"   // Compute vector from surface to light position\n"
					"   VP = vec3 (PointLightSource[i].position) - ecPosition3;\n\n"
					"   // Compute distance between surface and light position\n"
					"   d = length(VP);\n\n"
					"   // Normalize the vector from surface to light position\n"
					"   VP = normalize(VP);\n\n"
					"   // Compute attenuation\n"
					"   attenuation = 1.0 / (PointLightSource[i].attenuation[0] +\n"
					"       PointLightSource[i].attenuation[1] * d +\n"
					"       PointLightSource[i].attenuation[2] * d * d);\n\n"
					"   halfVector = normalize(VP + eye);\n\n"
					"   nDotVP = max(0.0, dot(normal, VP));\n"
					"   nDotHV = max(0.0, dot(normal, halfVector));\n\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += PointLightSource[i].ambient * attenuation;\n"
					"   Diffuse  += PointLightSource[i].diffuse * nDotVP * attenuation;\n"
					"   Specular += PointLightSource[i].specular * pf * attenuation;\n"
					"}\n";

			const char glsl_light_spot[]=
					"struct SpotLight\n"
					"{\n"
					"\tvec3 position;\n"
					"\tvec3 direction;\n"
					"\tvec3 attenuation;\n"
					"\tfloat coscutoff;\n"
					"\tfloat exponent;\n"
					"\n"
					"\tvec4 ambient;\n"
					"\tvec4 specular;\n"
					"\tvec4 diffuse;\n"
					"};\n"
					"\n"
					"void spotLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)\n"
					"{\n"
					"   float nDotVP;            // normal . light direction\n"
					"   float nDotHV;            // normal . light half vector\n"
					"   float pf;                // power factor\n"
					"   float spotDot;           // cosine of angle between spotlight\n"
					"   float spotAttenuation;   // spotlight attenuation factor\n"
					"   float attenuation;       // computed attenuation factor\n"
					"   float d;                 // distance from surface to light source\n"
					"   vec3  VP;                // direction from surface to light position\n"
					"   vec3  halfVector;        // direction of maximum highlights\n\n"
					"   // Compute vector from surface to light position\n"
					"   VP = vec3 (SpotLightSource[i].position) - ecPosition3;\n\n"
					"   // Compute distance between surface and light position\n"
					"   d = length(VP);\n\n"
					"   // Normalize the vector from surface to light position\n"
					"   VP = normalize(VP);\n\n"
					"   // Compute attenuation\n"
					"   attenuation = 1.0 / (SpotLightSource[i].attenuation[0] +\n"
					"       SpotLightSource[i].attenuation[1] * d +\n"
					"       SpotLightSource[i].attenuation[2] * d * d);\n\n"
					"   // See if point on surface is inside cone of illumination\n"
					"   spotDot = dot(-VP, normalize(SpotLightSource[i].direction));\n\n"
					"   if (spotDot < SpotLightSource[i].coscutoff)\n"
					"   {\n"
					"       spotAttenuation = 0.0; // light adds no contribution\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       spotAttenuation = pow(spotDot, SpotLightSource[i].exponent);\n\n"
					"   }\n"
					"   // Combine the spotlight and distance attenuation.\n"
					"   attenuation *= spotAttenuation;\n\n"
					"   halfVector = normalize(VP + eye);\n\n"
					"   nDotVP = max(0.0, dot(normal, VP));\n"
					"   nDotHV = max(0.0, dot(normal, halfVector));\n\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += SpotLightSource[i].ambient * attenuation;\n"
					"   Diffuse  += SpotLightSource[i].diffuse * nDotVP * attenuation;\n"
					"   Specular += SpotLightSource[i].specular * pf * attenuation;\n\n"
					"}\n";

			const char glsl_light_infinite_spot[]=
					"struct InfiniteSpotLight\n"
					"{\n"
					"\tvec3 position;\n"
					"\tvec3 direction;\n"
					"\tvec4 halfVector;\n"
					"\tfloat exponent;\n"
					"\n"
					"\tvec4 ambient;\n"
					"\tvec4 specular;\n"
					"\tvec4 diffuse;\n"
					"};\n"
					"\n"
					"void infiniteSpotLight(in int i, in vec3 normal)\n"
					"{\n"
					"   float nDotVP;         // normal . light direction\n"
					"   float nDotHV;         // normal . light half vector\n"
					"   float pf;             // power factor\n"
					"   float spotAttenuation;\n"
					"   vec3  Ppli;\n"
					"   vec3  Sdli;\n\n"
					"   nDotVP = max(0.0, dot(normal, normalize(vec3 (InfiniteSpotLightSource[i].position))));\n"
					"   nDotHV = max(0.0, dot(normal, vec3 (InfiniteSpotLightSource[i].halfVector)));\n\n"
					"   Ppli = -normalize(vec3(InfiniteSpotLightSource[i].position));\n"
					"   Sdli = normalize(vec3(InfiniteSpotLightSource[i].direction));\n\n"
					"   spotAttenuation = pow(dot(Ppli, Sdli), InfiniteSpotLightSource[i].exponent);\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += InfiniteSpotLightSource[i].ambient * spotAttenuation;\n"
					"   Diffuse  += InfiniteSpotLightSource[i].diffuse * nDotVP * spotAttenuation;\n"
					"   Specular += InfiniteSpotLightSource[i].specular * pf * spotAttenuation;\n"
					"}\n";
		}//namespace shadergen
	}//namespace graph
}//namespace hgl
