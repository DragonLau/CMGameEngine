namespace hgl
{
	namespace graph
	{
		namespace shadergen
		{
			const char glsl_light_directional[]=
					"void directionalLight(in int i, in vec3 normal)\n"
					"{\n"
					"   float nDotVP;         // normal . light direction\n"
					"   float nDotHV;         // normal . light half vector\n"
					"   float pf;             // power factor\n\n"
					"   nDotVP = max(0.0, dot(normal, normalize(vec3 (gl_LightSource[i].position))));\n"
					"   nDotHV = max(0.0, dot(normal, vec3 (gl_LightSource[i].halfVector)));\n\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += gl_LightSource[i].ambient;\n"
					"   Diffuse  += gl_LightSource[i].diffuse * nDotVP;\n"
					"   Specular += gl_LightSource[i].specular * pf;\n"
					"}\n";

			const char glsl_light_point[]=
					"void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)\n"
					"{\n"
					"   float nDotVP;       // normal . light direction\n"
					"   float nDotHV;       // normal . light half vector\n"
					"   float pf;           // power factor\n"
					"   float attenuation;  // computed attenuation factor\n"
					"   float d;            // distance from surface to light source\n"
					"   vec3  VP;           // direction from surface to light position\n"
					"   vec3  halfVector;   // direction of maximum highlights\n\n"
					"   // Compute vector from surface to light position\n"
					"   VP = vec3 (gl_LightSource[i].position) - ecPosition3;\n\n"
					"   // Compute distance between surface and light position\n"
					"   d = length(VP);\n\n"
					"   // Normalize the vector from surface to light position\n"
					"   VP = normalize(VP);\n\n"
					"   // Compute attenuation\n"
					"   attenuation = 1.0 / (gl_LightSource[i].constantAttenuation +\n"
					"       gl_LightSource[i].linearAttenuation * d +\n"
					"       gl_LightSource[i].quadraticAttenuation * d * d);\n\n"
					"   halfVector = normalize(VP + eye);\n\n"
					"   nDotVP = max(0.0, dot(normal, VP));\n"
					"   nDotHV = max(0.0, dot(normal, halfVector));\n\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += gl_LightSource[i].ambient * attenuation;\n"
					"   Diffuse  += gl_LightSource[i].diffuse * nDotVP * attenuation;\n"
					"   Specular += gl_LightSource[i].specular * pf * attenuation;\n"
					"}\n";

			const char glsl_light_spot[]=
					"void spotLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)\n"
					"{\n"
					"   float nDotVP;            // normal . light direction\n"
					"   float nDotHV;            // normal . light half vector\n"
					"   float pf;                // power factor\n"
					"   float spotDot;           // cosine of angle between spotlight\n"
					"   float spotAttenuation;   // spotlight attenuation factor\n"
					"   float attenuation;       // computed attenuation factor\n"
					"   float d;                 // distance from surface to light source\n"
					"   vec3  VP;                // direction from surface to light position\n"
					"   vec3  halfVector;        // direction of maximum highlights\n\n"
					"   // Compute vector from surface to light position\n"
					"   VP = vec3 (gl_LightSource[i].position) - ecPosition3;\n\n"
					"   // Compute distance between surface and light position\n"
					"   d = length(VP);\n\n"
					"   // Normalize the vector from surface to light position\n"
					"   VP = normalize(VP);\n\n"
					"   // Compute attenuation\n"
					"   attenuation = 1.0 / (gl_LightSource[i].constantAttenuation +\n"
					"       gl_LightSource[i].linearAttenuation * d +\n"
					"       gl_LightSource[i].quadraticAttenuation * d * d);\n\n"
					"   // See if point on surface is inside cone of illumination\n"
					"   spotDot = dot(-VP, normalize(gl_LightSource[i].spotDirection));\n\n"
					"   if (spotDot < gl_LightSource[i].spotCosCutoff)\n"
					"   {\n"
					"       spotAttenuation = 0.0; // light adds no contribution\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       spotAttenuation = pow(spotDot, gl_LightSource[i].spotExponent);\n\n"
					"   }\n"
					"   // Combine the spotlight and distance attenuation.\n"
					"   attenuation *= spotAttenuation;\n\n"
					"   halfVector = normalize(VP + eye);\n\n"
					"   nDotVP = max(0.0, dot(normal, VP));\n"
					"   nDotHV = max(0.0, dot(normal, halfVector));\n\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += gl_LightSource[i].ambient * attenuation;\n"
					"   Diffuse  += gl_LightSource[i].diffuse * nDotVP * attenuation;\n"
					"   Specular += gl_LightSource[i].specular * pf * attenuation;\n\n"
					"}\n";

			const char glsl_light_spot_direction[]=
					"void infiniteSpotLight(in int i, in vec3 normal)\n"
					"{\n"
					"   float nDotVP;         // normal . light direction\n"
					"   float nDotHV;         // normal . light half vector\n"
					"   float pf;             // power factor\n"
					"   float spotAttenuation;\n"
					"   vec3  Ppli;\n"
					"   vec3  Sdli;\n\n"
					"   nDotVP = max(0.0, dot(normal, normalize(vec3 (gl_LightSource[i].position))));\n"
					"   nDotHV = max(0.0, dot(normal, vec3 (gl_LightSource[i].halfVector)));\n\n"
					"   Ppli = -normalize(vec3(gl_LightSource[i].position));\n"
					"   Sdli = normalize(vec3(gl_LightSource[i].spotDirection));\n\n"
					"   spotAttenuation = pow(dot(Ppli, Sdli), gl_LightSource[i].spotExponent);\n"
					"   if (nDotVP == 0.0)\n"
					"   {\n"
					"       pf = 0.0;\n"
					"   }\n"
					"   else\n"
					"   {\n"
					"       pf = pow(nDotHV, gl_FrontMaterial.shininess);\n\n"
					"   }\n"
					"   Ambient  += gl_LightSource[i].ambient * spotAttenuation;\n"
					"   Diffuse  += gl_LightSource[i].diffuse * nDotVP * spotAttenuation;\n"
					"   Specular += gl_LightSource[i].specular * pf * spotAttenuation;\n"
					"}\n";
		}//namespace shadergen
	}//namespace graph
}//namespace hgl
